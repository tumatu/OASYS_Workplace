import numpydef enoise(x):    tmp = numpy.random.rand()    return x*tmpdef FindSlope(Name, flag, ty):    """    :param Name: "Name of wave with figure profile"    :param flag: Plot"    :param ty: Filter to apply"    :return:    """    # //___________________________________________________________________________________    # Function FindSlope(Name, flag, ty)    #    # 	String name    # 	String Flag    # 	String ty    # 	String options="Hanning;none;Bartlett"    # 	String flags="Yes;No"    # 	if (strlen(name)==0)    # 		ty="none"    # 		flag="No"    # 		Prompt name, "Name of wave with figure profile",popup,WaveList("*",";","DIMS:1")    # 		Prompt ty, "Filter to apply",popup, options    # 		Prompt flag, "Plot",popup, flags    # 		doPrompt "Name", name,flag,ty    # 		if (V_Flag)    # 			return -1								// User canceled    # 		endif    # 	endif    V_Flag = 0    # 	wave wHeight=$name    # 	wavestats/Q wHeight    # 	Variable npHeight=V_npnts					//Number of points original wave    # 	Variable delwHeight=DimDelta(wHeight,0)		//Step of height wave    # 	Variable offwHeight=DimOffset(wHeight,0)    # 	if(mod(npHeight,2)==1)						//Odd number of points    # 		DeletePoints 0,1, wHeight    # 		SetScale/P x offwHeight+delwHeight, delwHeight,"", wHeight    # 		npHeight-=1    # 	endif    # 	Variable lenHeight=npHeight*delwHeight    #    # 	Duplicate/O wHeight $"wFou"//,xvalue    # 	wave wFou    # 	strswitch(ty)						// string switch    # 		case "None":    # 			break    # 		case "Hanning":    # 			WindowFunction Hanning, wfou;  wfou*=2					//Hanning    # 			name=name+"_H"    # 			break    # 		case "Bartlett":    # 			WindowFunction Bartlett, wfou;  wfou*=2					//Hanning    # 			name=name+"_B"    # 			break    # 	endswitch    # 	FFT wfou    # 	wavestats/Q wfou    # 	Variable npFou=V_npnts    #    # 	String Amp=name+"_Amp"    # 	String Pha=name+"_Pha"    # 	String aPSD=name+"_aPSD"    # 	String aRMS=name+"_aRMS"    # 	String sPSD=name+"_sPSD"    # 	String sRMS=name+"_sRMS"    #    # 	Duplicate/O wfou $Amp, $Pha, $aPSD, $aRMS, $sPSD, $sRMS    # 	Redimension/R $Amp,     $Pha, $aPSD, $aRMS, $sPSD, $sRMS    # 	wave wAmp=$Amp    # 	wave wPha=$Pha    # 	wave waPSD=$aPSD    # 	wave waRMS=$aRMS    # 	wave wsPSD=$sPSD    # 	wave wsRMS=$sRMS    #    # 	wAmp=2/npHeight*Real(r2polar(wFou))				//Igor FFT Amplitude scaling    # 	wAmp[0]=1/npHeight*Real(r2polar(wFou[0]))			//Igor FFT Amplitude scaling    # 	wPha=Imag(r2polar(wFou))    # 	if(wAmp[0] <1e-20)    # 		wAmp[0]=wAmp[1]    # 	endif    # //	Display /W=(500,50,900,250) wAmp;  	ModifyGraph log=1    # //	waPSD=delwHeight*Magsqr(wFou)/npHeight    # 	waPSD=2*delwHeight*Magsqr(wFou)/(npHeight)    # 	if(waPSD[0] <1e-20)    # 		waPSD[0]=waPSD[1]    # 	endif    #    # //	Display /W=(500,250,900,450) waPSD;  	ModifyGraph log=1    # 	waRMS=waPSD    # 	Integrate/T waRMS    #  	waRMS=sqrt(waRMS)    # //	Display /W=(500,450,900,650)  waRMS; ModifyGraph log=1    #  	string Text, Text1    #    # 	wsPSD[0]=0    # 	Variable i    # 	for (i=1;i<npFou;i+=1)    # 		wsPSD[i]=	(2*pi*(i-1)/(npHeight*delwHeight))^2*waPSD[i]    # 	endfor    # // 	Display /W=(500,650,900,850)    wsPSD; ModifyGraph log=1    #    # //	wsRMS=wsPSD		//From OP 1.005    # 	wsRMS=2*pi^2*wAmp^2*x^2*lenHeight    # 	Integrate/T wsRMS    #  	wsRMS=sqrt(wsRMS)    # 	print Name,flag,ty,"FE:", waRMS[npFou-1],"SE:",wsRMS[npFou-1]    # 	if (cmpstr(flag, "Yes")==0)    # 		Display /W=(500,50,900,250) wAmp;  	ModifyGraph log=1    # 		Display /W=(500,250,900,450) waPSD;  	ModifyGraph log=1    # 		Display /W=(500,450,900,650)  waRMS; ModifyGraph log=1    # 		sprintf Text1, "RMS Height=%g",  waRMS[npFou-1]    # 		Textbox/F=0 Text1    #  	 	Display /W=(500,650,900,850)   wsRMS; ModifyGraph log=1    # 		sprintf Text, "RMS Slope=%g",  wsRMS[npFou-1]    # 		Textbox/F=0 Text    #  	else    #  		killwaves wAmp, waPSD, waRMS, wsRMS    #  	endif    #    #  end    #    # ////////////////////////////    #    #def Create1DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS):    # ////////////////////////////////////////////////////////////////////////////////////////////////////    # Function Create1DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS)    # 	Variable mirrorLength		//Mirror length    # 	Variable Step			//step    # 	Variable RandomSeed    # 	Variable SEorFE    # 	Variable RMS    # //	Prompt name, "Name of wave to create"    # 	if(Step ==0)    # 		mirrorLength=200		//Number of points surface wave    # 		Step=1			//Spacing surface wave    # 		RandomSeed=0.1    # 		SEorFE=0    # 		RMS=0.1e-6    # 		Prompt mirrorLength, "Enter mirror length, even"    # 		Prompt Step, "Step "    # 		Prompt RandomSeed, "Random seed between 0 and 1"    # 		Prompt SEorFE, "Figure error (0) or Slope error (1)"    # 		Prompt RMS, "RMS value of the above"    # 		doPrompt "Input", mirrorLength, Step,RandomSeed, SEorFE, RMS    # 		if (V_Flag)    # 			return -1								// User canceled    # 		endif    # 	endif    if(Step ==0):        mirrorLength=200.0		#Number of points surface wave        Step=1			#Spacing surface wave        RandomSeed=8787        SEorFE=0        RMS=0.1e-6        # Prompt mirrorLength, "Enter mirror length, even"        # Prompt Step, "Step "        # Prompt RandomSeed, "Random seed between 0 and 1"        # Prompt SEorFE, "Figure error (0) or Slope error (1)"        # Prompt RMS, "RMS value of the above"        # doPrompt "Input", mirrorLength, Step,RandomSeed, SEorFE, RMS    numpy.random.seed(seed=RandomSeed)    # 	print mirrorLength, Step, RandomSeed,SEorFE, RMS    print ("mirrorLength: %f, Step: %f, RandomSeed: %d, SEorFE: %d, RMS: %g"%(mirrorLength, Step, RandomSeed,SEorFE, RMS))    # 	Variable mult1=2.1e-10    # 	Variable mult2=mult1    # 	Variable slo1=-1.5    # 	Variable slo2= slo1    # 	Variable chSlo=0.001    # 	String name="SF"    mult1=2.1e-10    mult2=mult1    slo1=-1.5    slo2= slo1    chSlo=0.001    name="SF"    #    # 	TODO: SetRandomSeed(RandomSeed)			//Call to get the angles and positions    # 	Variable npo=mirrorLength/step+1    npo=int(mirrorLength/Step+1)    #    # 	Make/N=(npo)/O/D $Name    # 	Wave wName=$Name    # 	SetScale/I x -mirrorLength/2,mirrorLength/2, "", wName    wName_x = numpy.linspace(-mirrorLength/2,mirrorLength/2,npo)    wName = numpy.zeros(npo)    #    # 	Variable freq=1/MirrorLength    freq=1.0/mirrorLength    #TODO    # 	Make/N=(npo)/O/D , FouAmp,FouFre,FouPha    # 	SetScale/I x freq,Step,"",  FouAmp,FouFre,FouPha    x = numpy.linspace(freq,freq+freq*((npo-1)*Step),npo)    FouAmp = numpy.zeros(npo)    FouFre = numpy.zeros(npo)    FouPha = numpy.zeros(npo)    # 	FouFre=x    # 	Variable i    FouFre=x    # 	for (i=0;i<nPo;i+=1)    # 		if(FouFre[i]<chSlo)    # 			FouAmp[i]=mult1*FouFre[i]^slo1    # 		else    # 			FouAmp[i]=mult2*FouFre[i]^slo2    # 		endif    # 	endfor    for i in range(npo):        if (FouFre[i] < chSlo):            FouAmp[i]=mult1*FouFre[i]**slo1        else:            FouAmp[i]=mult2*FouFre[i]**slo2    # 	variable fileNumber    # 	wName=0    # 	for (i=0;i<nPo;i+=1)    # 		FouPha[i] = enoise(pi)    # 		wName += FouAmp[i]*cos(-pi*2*x*FouFre[i]+FouPha[i]);    # 	endfor    for i in range(npo):        FouPha[i] = enoise(numpy.pi)        wName += FouAmp[i]*numpy.cos(-numpy.pi*2*wName_x*FouFre[i]+FouPha[i])    # 	if (SEorFE==1)    # 		Differentiate wName/D=SF_DIF    # 		wavestats/Q SF_DIF    # 		SF_DIF*=RMS/V_sdev    # //		wavestats/Q wName    # 		wName*=RMS/V_sdev    # 	else    # 		wavestats/Q wName    # 		wName*=RMS/V_sdev    # 	endif    V_sdev = 1.0 #TODO chech this variable    if (SEorFE == 1):        #TODO        # Differentiate wName/D=SF_DIF        #wavestats/Q SF_DIF        SF_DIF = numpy.gradient(wName,Step)        SF_DIF*=RMS/V_sdev        wName*=RMS/V_sdev    else:        #TODO        #wavestats/Q wName        V_sdev = wName.std()        print("Standard deviation before rescaling",V_sdev)        #wName*=RMS/V_sdev        wName*=RMS/V_sdev        print("Standard deviation after rescaling",wName.std())    return wName_x,wName    # 	Display wName    # end    #def Create2DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS, mirrorWidth,StepW,RandomSeedW,SEorFEW,RMSW):    """    :param mirrorLength: "Enter mirror length, even"    :param Step: "Step folr length "    :param RandomSeed: "Random seed between 0 and 1"    :param SEorFE: "Figure error (0) or Slope error (1)"    :param RMS: "RMS value of the above"    :param mirrorWidth: "Enter mirror Width, even"    :param StepW: "Step for width"    :param RandomSeedW: "Random seed between 0 and 1"    :param SEorFEW: "Figure error (0) or Slope error (1)"    :param RMSW: "RMS value of the above"    :return:    """    numpy.random.seed(seed=RandomSeed)    # ////////////////////////////////////////////////////////////////////////////////////////////////////    # Function Create2DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS, mirrorWidth,StepW,RandomSeedW,SEorFEW,RMSW)    # 	Variable mirrorLength		//Mirror length    # 	Variable Step			//step    # 	Variable RandomSeed    # 	Variable SEorFE    # 	Variable RMS    # 	Variable mirrorWidth		//Mirror length    # 	Variable StepW			//step    # 	Variable RandomSeedW    # 	Variable SEorFEW    # 	Variable RMSW    # //	Prompt name, "Name of wave to create"    # 	if(Step ==0)    # 		mirrorLength=200		//Number of points surface wave    # 		Step=1			//Spacing surface wave    # 		RandomSeed=0.1    # 		SEorFE=0    # 		RMS=0.1e-6    # 		mirrorWidth=20		//Number of points surface wave    # 		StepW=1			//Spacing surface wave    # 		RandomSeedW=0.2    # 		SEorFEW=0    # 		RMSW=1e-6    # 		Prompt mirrorLength, "Enter mirror length, even"    # 		Prompt Step, "Step folr length "    # 		Prompt RandomSeed, "Random seed between 0 and 1"    # 		Prompt SEorFE, "Figure error (0) or Slope error (1)"    # 		Prompt RMS, "RMS value of the above"    # 		Prompt mirrorWidth, "Enter mirror Width, even"    # 		Prompt StepW, "Step for width"    # 		Prompt RandomSeedW, "Random seed between 0 and 1"    # 		Prompt SEorFEW, "Figure error (0) or Slope error (1)"    # 		Prompt RMSW, "RMS value of the above"    # 		doPrompt "Input", mirrorLength, mirrorWidth, Step, StepW, RandomSeed, RandomSeedW, SEorFE, SEorFEW, RMS, RMSW    # 		if (V_Flag)    # 			return -1								// User canceled    # 		endif    # 	endif    if Step == 0:        mirrorLength=200		#Number of points surface wave        Step=1			#Spacing surface wave        RandomSeed=0.1        SEorFE=0        RMS=0.1e-6        mirrorWidth=20		#Number of points surface wave        StepW=1			#Spacing surface wave        RandomSeedW=0.2        SEorFEW=0        RMSW=1e-6    # //	print mirrorLength, Step, RandomSeed,SEorFE, RMS    # //	print mirrorWidth, StepW, RandomSeedW,SEorFEW, RMSW    # 	Create1DFile(mirrorWidth, StepW, RandomSeedW,SEorFEW, RMSW)    WW_x, WW = Create1DFile(mirrorWidth, StepW, RandomSeedW,SEorFEW, RMSW)    # 	wave SF    # 	Duplicate/O SF, mwidth    # 	Display mWidth    # 	Variable npoW, NpoL    # 	npoW=DimSize(mWidth, 0 )    # 	Create1DFile(mirrorLength, Step, RandomSeed,SEorFE, RMS)    # 	npoL=DimSize(SF, 0 )    # 	print npoW,npoL    SF_x, SF = Create1DFile(mirrorLength, Step, RandomSeed,SEorFE, RMS)    npoL = SF.size    npoW = WW.size    print("Size Length: %d, Size Width: %d"%(npoL,npoW))    # 	make/O/N=(npoW,npoL) mirr    # 	SetScale/P x DimOffset(mWidth,0 ), DimDelta(mWidth,0 ),"", mirr    # 	SetScale/P y DimOffset(SF,0 ), DimDelta(SF,0 ),"", mirr    # 	variable i    # 	do    # 		Mirr[i][]=SF[q]+mWidth[i]    # 		i+=1    # 	While(i<npoW)    # 	string cmd    # 	sprintf cmd, "GizmoRuben(\"mirr\",\"Length (mm)\",\"Width (mm)\",\"Height (mm)\",0)"    # 	PRINT cmd    # 	execute cmd    #    # end    #    s = numpy.zeros( (npoL,npoW) )    for i in range(npoW):        s[:,i]=SF+WW[i]    #    #    return WW_x,SF_x,sdef test_1d():    mirrorLength = 200.0 # mm    Step = 1.0    RandomSeed = 898882    SEorFE = 0 # 0 = Figure, 1=Slope    RMS = 1e-7 # mm (0.1 nm)    wName_x,wName = Create1DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS)    return wName_x,wNamedef test_2d():    mirrorLength = 200.0 # mm    Step = 1.0    RandomSeed = 898882    SEorFE = 0 # 0 = Figure, 1=Slope    RMS = 1e-7 # mm (0.1 nm)    mirrorWidth = 100.0    StepW = 1.0    RandomSeedW = 7243364    SEorFEW = 0    RMSW = 1e-7    x,y,z = Create2DFile(mirrorLength,Step,RandomSeed,SEorFE,RMS, mirrorWidth,StepW,RandomSeedW,SEorFEW,RMSW)    return x,y,zif __name__ == "__main__":    try:        from matplotlib import pylab as plt    except:        raise ImportError    test_number = 2 # 0 = all    if test_number == 1 or test_number == 0:        wName_x,wName = test_1d()        f1 = plt.figure(1)        plt.plot(wName_x,wName)        plt.title("heights profile")        plt.xlabel("Y [mm]")        plt.ylabel("Z [um]")        plt.show()    if test_number == 2 or test_number == 0:        WW_x,SF_x,s = test_2d()        print(WW_x.size,SF_x.size,s.size,WW_x.size*SF_x.size)        from mpl_toolkits.mplot3d import Axes3D        from matplotlib import cm        from matplotlib.ticker import LinearLocator, FormatStrFormatter        import matplotlib.pyplot as plt        fig = plt.figure()        ax = fig.gca(projection='3d')        X, Y = numpy.meshgrid(WW_x, SF_x)        surf = ax.plot_surface(X, Y, s, rstride=1, cstride=1, cmap=cm.coolwarm,                linewidth=0, antialiased=False)        #ax.set_zlim(-1.01, 1.01)        ax.zaxis.set_major_locator(LinearLocator(10))        ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))        fig.colorbar(surf, shrink=0.5, aspect=5)        plt.show()